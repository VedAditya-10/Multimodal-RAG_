"""Export functionality with two options:
1. Download as Markdown file
2. Save to Obsidian via REST API
"""
import os
import httpx
from datetime import datetime
from typing import Optional
from loguru import logger


# Obsidian Local REST API settings
OBSIDIAN_API_URL = os.getenv("OBSIDIAN_API_URL", "http://127.0.0.1:27123")
OBSIDIAN_API_KEY = os.getenv("OBSIDIAN_API_KEY", None)


def format_conversation_markdown(
    query: str,
    answer: str,
    citations: list[dict],
    confidence: float,
    conflicts: list[dict] = None,
) -> str:
    """
    Format conversation as markdown.
    
    Returns markdown string ready for download or Obsidian.
    """
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
    
    # Build citation list
    citation_lines = []
    for i, cite in enumerate(citations):
        source = cite.get("source_file", "Unknown")
        modality = cite.get("modality", "unknown")
        snippet = cite.get("text_snippet", "")[:200]
        location = _format_location(cite.get("location", {}))
        cite_conf = cite.get("confidence", 0)
        
        citation_lines.append(
            f"{i+1}. **{source}** ({modality}, {cite_conf*100:.0f}% match)\n"
            f"   - Location: {location}\n"
            f"   - > {snippet}..."
        )
    
    # Build conflict section
    conflict_section = ""
    if conflicts:
        conflict_section = "\n## ⚠️ Conflicts Detected\n\n"
        for c in conflicts:
            conflict_section += f"- **{c.get('claim', 'Unknown')}**: {c.get('reason', '')}\n"
    
    markdown = f"""---
type: query
timestamp: {datetime.now().isoformat()}
confidence: {confidence:.2f}
citations: {len(citations)}
conflicts: {len(conflicts) if conflicts else 0}
---

# Query - {timestamp}

## Question
{query}

## Answer
{answer}

## Confidence Score
**{confidence*100:.0f}%**

## Evidence Citations
{chr(10).join(citation_lines) if citation_lines else "No citations available"}
{conflict_section}
---
*Generated by TRACE Multimodal RAG System*
"""
    
    return markdown


async def save_to_obsidian(
    query: str,
    answer: str,
    citations: list[dict],
    confidence: float,
    conflicts: list[dict] = None,
    api_key: str = None,
    api_url: str = None,
) -> dict:
    """
    Save conversation to Obsidian via Local REST API.
    
    Uses provided credentials, or falls back to .env file.
    
    Returns:
        dict with status, filename, and error message if failed
    """
    # Use provided credentials or fall back to environment
    obsidian_key = api_key or OBSIDIAN_API_KEY
    obsidian_url = api_url or OBSIDIAN_API_URL
    
    if not obsidian_key:
        return {
            "status": "error",
            "message": "Obsidian API key not configured. Set it in Export settings or OBSIDIAN_API_KEY in .env file."
        }
    
    try:
        # Generate filename
        timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
        filename = f"TRACE Query - {timestamp}.md"
        
        # Format markdown
        content = format_conversation_markdown(query, answer, citations, confidence, conflicts)
        
        # Send to Obsidian API
        headers = {
            'Authorization': f'Bearer {obsidian_key}',
            'Content-Type': 'text/markdown'
        }
        
        async with httpx.AsyncClient(timeout=10) as client:
            response = await client.put(
                f"{obsidian_url}/vault/{filename}",
                headers=headers,
                content=content.encode('utf-8')
            )
        
        if response.status_code in [200, 201, 204]:
            logger.info(f"Saved to Obsidian: {filename}")
            return {
                "status": "success",
                "filename": filename,
                "message": f"Saved to Obsidian as {filename}"
            }
        else:
            error_msg = f"Obsidian API error: {response.status_code}"
            logger.error(f"{error_msg} - {response.text}")
            return {
                "status": "error",
                "message": error_msg
            }
            
    except httpx.ConnectError:
        return {
            "status": "error",
            "message": "Cannot connect to Obsidian. Make sure Local REST API plugin is installed and running."
        }
    except Exception as e:
        logger.error(f"Obsidian save failed: {e}")
        return {
            "status": "error",
            "message": f"Failed to save: {str(e)}"
        }


def _format_location(location: dict) -> str:
    """Format location dict for display."""
    parts = []
    
    if location.get("page"):
        parts.append(f"Page {location['page']}")
    
    if location.get("timestamp_start") is not None:
        start = location["timestamp_start"]
        end = location.get("timestamp_end", start)
        parts.append(f"{start:.1f}s - {end:.1f}s")
    
    if location.get("line_start"):
        end = location.get("line_end", location["line_start"])
        parts.append(f"Lines {location['line_start']}-{end}")
    
    if location.get("bbox"):
        parts.append("BBox available")
    
    return ", ".join(parts) if parts else "N/A"
